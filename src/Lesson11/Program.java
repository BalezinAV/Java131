package Lesson11;

public class Program {
    public static void main(String[] args) {
        // Объектно ориентированное программирование.
        // Инкапсуляция, Наследование, Полиморфизм - 3 парадигмы.
        // Класс и объект. 05.02.2024 Лекция от 05.02.2024 -2- 0.04
//        Person p1 = new Person(); // Создали объект (экземпляр класса). new - выделает память под объект Person и p1 ссылается на эту память.
        // p1 - экземпляр класса Person.
//        p1.displayInfo(); // При запуске отработал конструктор по умолчанию. Строка null, число 0.

//    p1.name = "Виктор";
//    p1.age = 28;
//    p1.displayInfo();

//        Person p2 = new Person("Игорь");
//        p2.displayInfo();

        Person p3 = new Person("Валентин", 625); // Нужно тоже проверить эти данные. Идем в конструктор
//        p3.name = "Николай"; // Если у нас свойство указано через private, то на прямую теперь обратиться не можем.
        p3.setName("Николай");// Обращаемся через set
//        p3.setAge(666);
        System.out.println(p3.getAge());
        System.out.println(p3.getName());
        //        p3.age = 1128; // Сейчас не можем получить доступ к этой переменной (privet).
        p3.displayInfo();

//        Person p4 = new Person(30);
//        p4.displayInfo();

    }
}

class Person { // Класс это шаблон, на основе которого можно создать любое количество объектов. Без мадификатора и виден в пределеах нашего пакета.
    // Создаем свойства, поля (переменные), методы.
//    String name; // Это свойства или поля, они видны в пределах всего класса.
//        int age;
//    public String name; // Доступ есть абсолютно везде.
    private String name; // Доступ есть только в этом классе.
    private int age; // Закрытое, либо защищенное свойство. Видно в пределах своего класса. Закрывать доступ нужно

    public String getName(){
        return name;
    }
    public  void setName(String name){
        this.name = name;
    }
    public int getAge(){ // Геттер для получения доступа к возрасту.
        return age;
    }

    public void setAge(int age) { // Сеттер для нового значения возраста.
        if (age > 0 && age < 110){
            this.age = age;
        }
    }

    //    { // Инициализатор. Где будет написан, не принципиально. Начальную иници., может выполнять иниц. До любого конструктора. Если перенести после конструкторов, то он не отработает.
//name = "Певроначальное значение"; // Если в конструкторе не задана переменная (name) то возьмется от сюда.
//age = 100; // Если в конструкторе не задана переменная (age) то возьмется от сюда.
//    }
//    // Конструктор создается сразу после указания полей, либо свойств. Но пинципиальной разници нет.
//public Person(){ // () то есть мы ничего не принмаем. Конструктор должен иметь такоеже имя как наш класс.
//    name = "Неизветсно"; // Конструктор без параметров, обрабатывает для певого экземпляра класса.
//    age = 18;
//}
    // Такой конструктор должен быть всегда
    public Person(){} // Это заменяе конструктор по умолячянию для p1.
    //public Person(String n){
//    name = n; // Сюда придет значение из p2. Игорь перезаписался , а age взялось по умолчанию.
    // Для втрого экземпляра класса отрабатывает конструктор с одним параметром.
    // С левой стороны относится к свойству, с правой к переменной свойства.
//}
//    public Person(int a) { // Конструктор с возрастом
//        age = a; // Принимаемый аргумент, за предела метода он не виден, по этопу пи выводе обращаемся к свойствам (name, age).
//    }
//public Person(String n, int a){ // Конструктор для двух параметров для третьего экземпляра класса.
//    name = n;
//    age = a;
//}
    public Person(String name, int age){
//        this.name = name;
//        this.age = age;
        setName(name); // Так мы можем пройти проверку возраста через ранее написанное условие.
        setAge(age);
    }

    // Два поля. Значения в чистом виде не сохранили. Когда создали экземпляр класса, мы создаем два объекта. Экземпляр p1 - имя и возраст; p2 - имя и возраст. Объкт ссылается на класс Person. Конструктор по умолчанию работает пока не создан другой конструктор.
    void displayInfo() {
//        System.out.printf("Name: %s%nAge: %d%n", name, age); // Здесь мы обратились к свой свойствам. Очень часто делают одинаковые имена, но при этом добавляют к левой части (this.) и при выводе. Таким образом мы даем сылку на конкретный экземпляр класса.
        System.out.printf("Name: %s%nAge: %d%n", this.name, this.age);

        // Дома прочитать теорию. Работа конструктора и работа инкапсуляции (сет и гет). Ссылочки в ДЗ. Ответ ввиде комментария прислать : прочитал.

        // Лекция от 07.02.2024
        // Если создаем два класса в одном документе, у каждого класса должне быть сой public.
        // Содаем новый пакет в лессон 11 и в нем новый класс хюман и майн.
    }
}

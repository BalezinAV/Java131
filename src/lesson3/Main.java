package lesson3;

import java.util.Scanner;
import java.util.Arrays;
import java.util.ArrayList;
// import java.util.*; // Это импорт всех инструментов.

public class Main {

    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        // Циклы - нужные для однотипного набора действий множество раз.
        /*
        while(условие){ // (;) не стваим. Нужно чтобы было true, только в этом случае мы попадем в тело цикла.
        тело цикла; // внутри тела цикл (;) ставим
        }// (;) не ставим. Если одна строка, то фигурные скобки можно не ставить, но мы будем ставить.
         Итерация - это один шаг цикла (один раз).
         */
       /* int i = 0; // переменная счетчик - считает количество итераций.
        while (i < 5){ // условие. Пока i<5 цикл будет выполняться, а переменная при этом будет перезаписоваться, так как (i++).
            System.out.println("I = " + i); // вывод информации.
            ++i; // Шаг цикла. Условие работы и выхода из цикла.
        }*/
       /* int i = 100;
        // i < 0 - мы не попадем в while
        while (i > 0){
            System.out.println(i);
            //i--; // i = i - 1
            //i = i - 10; // задали новый шаг при помощи выражения.
            i = i / 5;
        }*/
        // задача. вывести только четные числа в диапазоне от 1 до 20.
//        более универсальное решение!
//        int i = 1; // начало диапазона
//        while (i <= 20){
//            if(i % 2 == 0){ // условие проверки на четность
//                System.out.println(i);
//            }
//            i++;
//        }
        // еще вариант
//        int i = 0; // нарушено условие задачи, но тоже работает.
//        while (i < 20){
//            //i = i + 2;
//            i += 2;
//            System.out.println(i);
//        }

//        int count = 3; // кол-во итерации, которое будет выполняться
//        int n, sum = 0; // sum = 0 для корректного подсчета. Нам нужно обозначить начальное значение переменной
//        while (count > 0){
//            System.out.print("Введите число: ");
//            n = input.nextInt(); // при каждой итерации (n) будет перезаписоваться.
//            sum += n; // sum = sum + n
//            count--; // счетчик
//        }
//        System.out.println("Сумма веденных чисел: " + sum);
        // задача на ввод цифр и подсчет суммы. цикл работает до момента ввода не числового значения.
//        int n, sum = 0;
//        System.out.print("Введите число: ");
//        while (input.hasNextInt()){ //это оператор проверки на ввод числа и не числа. Этот оператор понимает что мы
//            // вводим на всех этапах работы программы.
//            System.out.print("Введите число: ");
//            n = input.nextInt();
//            sum += n; // sum = sum + n
//            }
//        System.out.println("Сумма чисел: " + sum);

        // найти сумму нечетных чисел в диапазоне указанным пользователем
        // 1, 2, 3, 4, 5. 1+3+5 = 9
       /* int a, b, sum = 0;
        System.out.print("Введите начало диапазона: ");
        a = input.nextInt();
        System.out.print("Введите конец диапазона: ");
        b = input.nextInt();
        while (a <= b){
            if(a % 2 != 0){
                System.out.println(a + " ");
                sum += a;
            }
            a++;
        }
        System.out.println("Сумма нечетных чисел: " + sum);*/
        // далене слушать лекцию от 06.12.2023
        // 06/12/2023
        //задача
//        int n, orient;
//        System.out.print("Количество символов: ");
//        n = input.nextInt();
//        String symbol;
//        System.out.print("Тип символа: ");
//        symbol = input.next();
//        System.out.print("0 - горизонтальная\n1 - вертикальная\nориентация линии: ");
//        orient = input.nextInt();
//
//        while (n > 0) {
//            if (orient == 0) {
//                System.out.print(symbol + " ");
//            } else {
//                System.out.println(symbol);
//            }
//            n--;
//        }

       /* int n;
        String str;
        System.out.print("Введите число: ");
        n = input.nextInt(); //когда нажиаем ентер, то автоматически добавлчется (\n - непечатаемый символ), который попадает в качестве
        // следующего символа, который нужно ввести и получается, что нажимая ентер, мы вводим следующи символ.
        // Так как int это целое число, он не может принять строковое значение (\n) и оно попадает в нашу строковую переменную.
        System.out.println(n); // 6\n - получается такой ввод. Так (\n) это символ - команда, то он не отображается. Но при
        // этом он востпринимаетя как введенный нами символ.
        input.nextLine(); // теперь (\n) попадает сюда и все работает корректно.
        System.out.print("Введите строку: ");
        str = input.nextLine(); // при работе программы сюда попадаент (\n)
        System.out.println(str);*/

        // смотрим дебагер - можно отслеживать работу программы и найти возможные ошибки.
        /*int i = 1, sum = 0;
        while (i <= 20) {
            if (i % 2 == 0) {
                sum += i;
                }
            i++;
        }
        System.out.println(sum);*/

        /*
        do{ //нет проверки условия, по этому он выполнится хотя бы один раз. Условие будет проверяться когда
        //выполнится один раз тело цикла.
        тело цикла;
        }while(условие);
         */
        //int i = 0;
//        do { // делай, заходи и выполняй!
//            System.out.println("i = " + i); // i = 0
//            i++; // 1
        //}while (i < 5); // 1 < 5
        //}while (i > 5); // 1 > 5 отработает один раз и выдаст результат после проверки.

        //while (i < 5){
//        while (i > 5){ // сразу пойдет проверка и ничего не выведится.
//            System.out.println("i = " + i);
//            i++;
//        }

        //Задачка вводим любые цифры и считаем среднее арифметическое отрицательных чисел, до тех пор, пока не введем "0".
//        int n, sum = 0, count = 0; //если хотим считать сумму, то переменную в которую содираем сумму, всегда инициализируеи 0!
//        double average;
//        do {
//            System.out.print("Введите число (0 - прервет программу): ");
//            n = input.nextInt();
//            if(n < 0){
//                sum += n;
//                count++;
//            }
//        }
//        while (n != 0);
//        average = (double) sum / count; // sum / count - целочисленное деление, знаки после запятой принудительно
//        // добавятся так как (double average), но знаков после запятой не будет так как делятся переменные типа int. Нужно сделать изменение типа данных
//        System.out.println("Всего отрицательных чисел " + count);
//        System.out.printf("Среднее арифметическое отрицательных числе: %.2f", average);

        // Задача. Определить палиндром - это число или текст, который читается в обе стороны одинаково (121, 55555, 3455543, 11611, ...)
//        int number, copy, rev_number = 0, i;
//        System.out.print("Введите число: ");
//        number = input.nextInt(); // 321
//        copy = number; // 321 - нужно развернуть. => 32 => 3
//        do {
////            i = copy % 10; // 321%10=1 - дает последнюю цифру в числе.-> 2 -> 3
////           // rev_number = i * 10; //rev_number = 1 * 10 = 10 + 2 = 12
////            rev_number = rev_number * 10 + i; // 0*10+1=1 // 1*10+2=12 // 12*10+3=123
//            rev_number *= 10; // rev_number =rev_number*10//0//1*10=10//12*10=120
//            rev_number += copy % 10; // rev_number = rev_number+*= copy % 10=>0+1=1//10+(32%10)2=12//120+(3%10)3=123
//            copy /= 10; // 321/10=32 => 32/10=3 => 2/10=0 так как у нас целочисленное значение int
//            System.out.println(copy);
//        }while (copy > 0);
//        System.out.println(rev_number);
//        System.out.println("Число " + number + (number == rev_number? " " : " не ") + "палиндром");

//        int i = 0;
//        while (i < 10){
//            System.out.println(i);
//            if (i == 5) { // теперь будем попадать в (i++). (i==5) условие прерывания цикла.
//                break; // мы не дойдем до (i++) ни разу. Он используется при каком-то определенном условии.
//            }
//                i++;
//        }
//        System.out.println("Цикл завершен");

//        int i = 0;
//        do {
//            System.out.println(i);
//            if (i == 5) {
//                break;
//            }
//            i++;
//        }while (i < 10);
//        System.out.println("Цикл завершен");

        //вариант с (continue)
//        int i = 0;
//        while (i < 10){
//            if(i == 3){ // не выводит (3). при достижении 3 мы попадаем в 1й (if) и при помощи (i++) увеличим до 4
//                i++; // 4 - после того как нижний (i++) дошел до 3. Этот счетчик, нужен если мы увеличиваем переменную внизу. Если вверху, то счетчик не нужен.
//                continue; // после достижения 4, оператор нам не даст пойти ниже и перебросит на (while) для проверки условия. Мы изменили (i++) на 4, чтобы выйти из первого условия.
//            }
//            System.out.println(i);
//            if (i == 5) {
//                break;
//            }
//            i++; // 1->2->3->5
//        }
//        System.out.println("Цикл завершен");

//        int i = 0;
//        do {
//            if (i == 3) {
//                i++;
//                continue;
//            }
//            System.out.println(i);
//            if (i == 5) {
//                break;
//            }
//            i++;
//        }while (i < 10);
        //вариант с (i++) вверху
        /*int i = 0;
        do {
            i++; // тогда мы не получаем (0) в при выводе, так как сразу увеличиваем (i).
            if (i == 3) {
                continue;
            }
            System.out.println(i);
            if (i == 5) {
                break;
            }
        }while (i < 10);*/

        //Бесконечный цикл
        /*int i = 0;
        while (true){ // мы не знаем сколько итераций будет происходить.
            System.out.println(i);
            if(i == 5){ // это условие прерывает бесконечный цикл.
                break;
            }
            i++;
        }*/
        // Вариант неизвестного числа итераций (while (true))
        /*int n;
        while (true){ // так пользователь может вводить числа сколько угодно. И получаем бесконечное количество итераций
            System.out.print("Введите положительное число: ");
            n = input.nextInt();
            if(n < 0){ // это условие выхода
                break;
            }
        }*/

        // Задача. Программа поиска произведения + и - чисел, пока не введен 0.
       /* int pr = 1, eee;
        while (true){
            System.out.print("Введите число, кроме (0): ");
            eee = input.nextInt();
            if(eee == 0){ // проверка ввода 0
                break;
            }
            pr = pr * eee; // должно считаться до того, когда мы ввели 0. По этому делаем расчет после (break)
        }
        System.out.println("pr = " + pr);*/
        // ДЗ_6 от 06.12.23 пара 12. 1.10
        // Разбор ДЗ от 06.12.23 в начале лекции от 11.12.23

        // Лекция 11.12.23 Вложенные циклы
//        int i = 1;
//        while (i < 5){ // Отработает 1й шаг внешнего цикла и заходим во внутренний и отрабатываем внутренний цикл (1-3).
//            // Потом переходим во 2й шаг внешнего цикла. Затем отрабатывается снова внутренний цикл.
//            System.out.println("Внешний цикл: i = " + i);
//            int j = 1;
//            while (j < 4){
//                System.out.println("\tВнутренний цикл: j = " + j); // "\t" - табуляция
//                j++; // Счетчик j
//            }
//            i++; // Счетчик i. Если не сделать это условие увеличения на 1, то цикл будет бесконечно выводить 1.
//        }
        // Вариант с другой работой вложенного цикла
//        int i = 1;
//        int j = 1; // Переменная (j) объявлена вверху. Вложенный цикл отработает всего один раз.
//        while (i < 5){
//            System.out.println("Внешний цикл: i = " + i);
//            while (j < 4) {
//                System.out.println("\tВнутренний цикл: j = " + j); // "\t" - табуляция
//                j++;
//            }
//            i++;
//        }

        //Рисуем таблицу умножения
//        int i = 0;
//        while (i < 5){
//            System.out.print(i + " "); // вывод по горизонтали
//            //System.out.println(i + " "); // вывод по вертикали
//            i++;
//        }
//        int i = 1;
//        while (i < 10){
//            int j = 1;
//            while (j < 10){
//                System.out.print(i + " * " + j + " = " + i * j + "\t\t");
//                j++; // это столбцы
//            }
//            System.out.println();//Сделали перенос строк между циклами
//            i++; // это строки
//        }
        // Выводим прямоугольник из символов (^)
//        int i = 0; // чаще инициализируют через 0
//        while (i < 3){ // это строки
//            int j = 0;
//            while (j < 6){ // это столбцы
//                System.out.print("^");
//                j++;
//            }
//            System.out.println();
//            i++;
//        }
        // Необходимо вывести строки с (+) и (-)
//        int pl = 0;
//        while (pl < 5){ // строки
//            int mi = 0;
//            while (mi < 16){ // столбцы
//                if (pl % 2 == 0){
//                    System.out.print("+"); // выводит четную строку, так как 0 % 2=0, то певая строка выйдет (+) и вторая тоже выйдет (+)
//                }
//                else {
//                    System.out.print("-"); // нужен для чтобы не четная строки
//                }
//                mi ++;
//            }
//            System.out.println();
//            pl ++;
//        }
        // Вывести диагональ из (*) - это (*) и (пробел)
//        int i = 0;
//        while (i < 5){ // 0<5; 1<5; 2<5; 3<5; 4<5; 5<5 - false заканчивается внешний цикл.
//            int j = 0; // таким образом у нас всегда внутренний цикл начинаем с 0
//            while (j < i){ //0<0-false(не заходим во вложенный цикл);0<1-true(1 пробел);0<2(2а пробела - первый 0<2,
//                // второй 1<2, затем 2<2 - false - выходим из внутреннего цикла); // для вывода пробелов
//                System.out.print(" ");
//                j ++;
//            }
//            System.out.println("*"); // за пределами вложенного цикла, чтобы (*) выводилась один раз.
//            i ++;
//        }

        // for - третий цикл. Для заданного количества итераций.
        /*
        for (инициализация_переменной; проверка условия; шаг_цикла){
        тело цикла;
         */
//        for (int i = 0; i < 5; i++){// Произошла инициализация 1 раз и произошла проверка условия, вывод.
//            // Далее увеличиваем счетчик на 1 и проверяем условия, повторной инициализации переменной не происходит,
//            // цикл работает между (i < 5) и (i++)
//            System.out.println(i);
//        }
//        int count = 0;
//        for (int i = 0; i < 6; i++){
//            System.out.print("-> ");
//            if (input.hasNextInt()){
//                count ++;
//            }
//            input.nextLine();
//            }
//        System.out.println("Вы ввели чисел: " + count);
        // Задача. Пользователь вводит число, а программа должна вывести количество символов, соответствующих введенному числу.
        // while
//        int i, j = 0;
//        System.out.print("Введите целое число: ");
//        i = input.nextInt();
//        while (j < i){
//            System.out.print("*");
//            j++;
//        }
        //for
//        System.out.print("Enter the number: ");
//        int a = input.nextInt();
//        for (int i = 0; i < a; i++){
//            //for (int i = 0; i < input.nextInt(); i++){ // если делать так, то программа потребует вводить число после каждый раз, при этом будет выводиться только по одной (*). Идет новая проверка и по этому цикл не сработает.
//            System.out.print("*");
//        }

        // Задача. Вывести числа, на которые введенное число делится без остатка.
//        int i, num;
//        System.out.print("Enter the number: ");
//        num = input.nextInt();
//        for (i = 1; i <= num; i++){// 0 не задаем, так как при первой итерации будет деление на 0, и программа выдаст ошибку.
//            if (num % i == 0){
//                System.out.println("Divided by: " + i);
//            }
//        }

//        for(int i = 10; i > 0; i--){ // i будет перезаписываться.
//            System.out.print(i + " ; ");
//        }

//        for(int i = 10; i < 100; i += 10){ // i = i + 10 -> так тоже можно.
//            System.out.print(i + " ; ");
//        }

        // Вынесем i за for
//        int i = 10;
//        for(; i < 100; i += 10){ // ; - нужна в скобках
//            System.out.print(i + " ; ");
//        }
        //Вынесем за for i+=10
//        int i = 10;
//        for(; i < 100;){ // ; - нужна в скобках
//            System.out.print(i + " ; ");
//            i += 10;
//        }
        //уберем условие выхода из цикла
//        int i = 10;
//        for(;;){ // i < 100 - убрали условие, но (;) должны остаться
//            System.out.print(i + " ; ");
//            if (i == 90){ // i < 100 так здесь работать не будет, цикл отработает 1-н раз
//                break; // Без if и break будет бесконечный цикл с увеличением на 10
//            }
//            i += 10;
//        }
        // без счетчика ищем произведения
//        int n, res = 1; // для произведений переменная инициализируется (1).
//        for (;/*true*/;){ // Можно true убрать. Он нужен как признак того, что цикл бесконечный.
//            System.out.print("-> ");
//            n = input.nextInt();
//            if(n == 0){ // попадаем в условие проверки до произведения.
//                break;
//            }
//            res *= n; // это позволит исключить 0 из произведения
//        }
//        System.out.println("Вы ввели 0. Программа завершилась.\nПроизведение введенных чисел: " + res);

        // В цикле можно использовать сразу несколько переменных.
        //int a = 1; // мы объявили переменную в for-е
//        for (int i = 5, a = 1; i > 0; i--, a++){
//            System.out.println(a + ") Значение: " + i);
//           // a++; // это счетчик, который можно вложить в for
//        }

//        for (int x = 0, y = 0; x < 5; x++, y--){
//            System.out.println("x: " + x + ", y: " + y);
//        }

        //Задача. Вывести целые числа в диапазоне от 10 до 100 у которых есть 2е одинаковые цифры. (11, 22, 33, 44, 55, 66, 77, 88, 99)
//        for (int i = 10; i < 100; i++) {
//    if (i % 11 == 0) {
//        System.out.print(i + " ");
//    }
//        }
        // Другой вариант
//        for (int i = 10; i < 100; i++){
//            if (i % 10 == i / 10){
//                System.out.print(i + " ; ");
//            }
//        }
        // ДЗ. Нарисовать при помощи вложенных циклов на while треугольник из (*) как на занятии, только добавить вертикальную линию.

        // Лекция от 13.12.2023 Вложенный for

//for (int i = 0; i < 3; i++){// Наружный цикл.
//    System.out.println("+++ = " + i);
//    for (int j = 0; j < 2; j++){// Вложенный цикл. При одной итерации внешнего цикла будут выполняться все итерации вложенного.
//        // Переменная j в каждой итерации внешнего цикла начинается с 0.
//        System.out.println("----- " + j);
//    }
//}
        // Задача. Нарисовать прямоугольник из (*) - закрашенный
//        int w, h;
//        System.out.print("Введите ширину прямоугольника: ");
//        w = input.nextInt();
//        System.out.print("Введите высоту прямоугольника: ");
//        h = input.nextInt();
//
//        for (int i = 0; i < h; i++){
//            for (int j = 0; j < w; j++){
//                System.out.print("*");
//            }
//            System.out.println();
//        }
        // Задача. Нарисовать прямоугольник из (*) - незакрашенный
//        int w, h;
//        System.out.print("Введите ширину прямоугольника: ");
//        w = input.nextInt();
//        System.out.print("Введите высоту прямоугольника: ");
//        h = input.nextInt();
//
//        for (int i = 0; i < h; i++){
//            for (int j = 0; j < w; j++){
//                if (i == 0 || i == h - 1 || j == 0 || j == w-1){
//                    System.out.print("*");
//                }else {
//                    System.out.print(" ");
//                }
//            }
//            System.out.println();
//        }
        // Закрашенный треугольник (*)
//        int size = 4;
//        for (int i = 0; i < size; i++){ //1)i=0;2)i=1;3)i=2;4)i=3;5)i=4 - вышли из for, программа закончена;
////            for (int j = 0; j < size; j++){//1.1)j=0;1.2)j=1;1.3)j=2;1.4)j=3;1.5)j=4 - вышли из вложенного for;2.1)j=0;2.2)j=1;2.3)j=2;2.4)j=3;2.5)j=4 - вышли из вложенного for;
//          for (int j = 0; j <= i; j++){ // еще вариант без if
////                if (j <= i){//1.1)0<=0:*;1.2)1<=0;1.3)2<=0;1.4)3<=0;1.5)4<=0;2.1)0<=1:*;2.2)1<=1:*;2.3)2<=1;2.4)3<=1;
//                    System.out.print("*");
////                }
//            }
//            System.out.println();
//        }
        // Задача. Нарисовать равнобедренный треугольник. (1.00)
//        int h = 7;
//        int w = h * 2 - 1;
//        int m = w / 2; // середина строки
//        for (int i = 0, l = m, r = m; i < h; i++, r++, l--){
//            for (int j = 0; j < w; j++){ //j = 0
//                if (j >= l && j <= r){ //0>=2 false
//                    System.out.print("*");
//                } else {
//                    System.out.print(" ");
//                }
//            }
//            System.out.println();
//        }
        // Задача. Вывести треугольник прямоугольный чтобы конус расходился снизу в верх.
//        int size = 7;
//        for (int i = 0; i < size; i++){
//            for (int j = 0; j < size; j++){
//                if (j >= i){
//                    System.out.print("*");
//            }
//            }
//            System.out.println();
//        }

        // Массивы. (1.20) и переходим на вторую часть лекции
//        int mas[] = new int [4]; // массив на 4 элемента. 0,1,2,3 - это индексы к которым относятся значения массива. Сейчас там везде 0.
//        int[] mas2 = new int [5];// массив на 5 элементов, в другом виде записи.
//        int mas3[];
//        mas3 = new int[4];
//        int mas[] = new int [4];
//        System.out.println(mas); // выведем код массива
//        System.out.println(mas[0]);//выводим число под индексом 0
//        System.out.println(mas[1]);
//        System.out.println(mas[2]);
//        System.out.println(mas[3]);//выводим число под индексом 3

//        int mas[] = new int [] {2, 7, 5, 3}; // Теперь это массив на 4 элемента. При этом из [] убрали длину массива.
//        System.out.println(mas);
//        System.out.println(mas[0]);
//        System.out.println(mas[1]);
//        System.out.println(mas[2]);
//        System.out.println(mas[3]);

        //int mas[] = {2, 7, 5, 3}; // другой способ записи массива

//        int mas[] = new int[4];
//        mas[0] = 5;
//        mas[1] = 2;
//        mas[2] = 7;
//        mas[3] = mas[1] + mas[2]; // 2 + 7 = 9. Получили сумму из значений, которые хранятся под индексами.
//        System.out.println(mas[0]);
//        System.out.println(mas[1]);
//        System.out.println(mas[2]);
//        System.out.println(mas[3]);
//        System.out.println(mas.length); // 4
//        int last = mas[mas.length - 1]; // mas[4-1]=[3] - это индекс - получаем число последнего индекса. Это такое правило!
//        //int last = mas.length - 1; // 3 - индекс последнего элемента.
//        System.out.println(last);

        // Совмещаем массив с циклом
//        int mas[] = new int[4];
//        mas[0] = 5;
//        mas[1] = 2;
//        mas[2] = 7;
//        mas[3] = mas[1] + mas[2];
//        for (int i = 0; i < 4; i++){
//            System.out.println(mas[i]);
//        }
//        int mas[] = new int[5];// 5-е число 0, потому что не задано.
//        mas[0] = 5;
//        mas[1] = 2;
//        mas[2] = 7;
//        mas[3] = mas[1] + mas[2];
//        for (int i = 0; i < mas.length; i++){
//            System.out.println(mas[i]);
//        }

//        int n = 100;
//        int[] a = new int[n * 2 + 3];
//        System.out.println(a.length);

//        int n = 10;
//        int[] a = new int[n];
//        a[n - 1] = 2; // a[9] = 2 мы присвоили 9-му индексу число 2.
//        a[n - 2] = 3; // a[8] = 3
//        a[n / 5] = a[n - 1] + a[n - 2]; // a[10/5 = 2] = a[9 (2)] + a[8(3)] => 5. Т.е., в индексе 2 будет храниться число 5.
//        System.out.println("Длинна массива " + a.length);
//        for (int i = 0; i < a.length; i++){
//            System.out.println("Индекс " + i + ") " + a[i]);
//        }

        // Создаем массив при помощи пользователя
//        int[] array = new int[4];
//        System.out.print("-> ");
//        array[0] = input.nextInt();
//        System.out.print("-> ");
//        array[1] = input.nextInt();
//        System.out.print("-> ");
//        array[2] = input.nextInt();
//        System.out.print("-> ");
//        array[3] = input.nextInt();
//        for (int i = 0; i < array.length; i++){
//            System.out.print(array[i] + " ");
//        }
        // Вариант ввода с циклом
//        int[] array = new int[4];
//        for (int i = 0; i < array.length; i++){
//            System.out.print("-> ");
//            array[i] = input.nextInt();
//        }
//        for (int i = 0; i < array.length; i++){
//            System.out.println(array[i] + " ");
//        }
        // Вариант с одним for
//        int[] array = new int[4];
//        for (int i = 0; i < array.length; i++){
//            System.out.print("-> ");
//            array[i] = input.nextInt();
//            System.out.println(array[i] + " "); // В этом случае мы сразу выводим введенные пользователем цифры.
//        }

        //Задача. Ввести количество элементов массива. Если введено 5, то все элементы 0.
        // Если меньше 5, то пользователь вводит значения.
//        int a;
//        System.out.print("Введите количество элементов массива: ");
//        a = input.nextInt();
//
//        int[] array; // это область видимости
//        if (a >= 5) {
//            array = new int[a];
//        } else {
//            array = new int[a];
//            for(int i = 0; i < array.length; i++){
//                System.out.print("-> ");
//                array[i] = input.nextInt();
//            }
//        }
//        for (int i = 0; i < array.length; i++) {
//            System.out.print(array[i] + " ");
//        }

        // Выводим массив в обратном порядке
//        int[] array = new int[10];
//        for (int i = 0; i < array.length; i++){
//            System.out.print("-> ");
//            array[i] = input.nextInt();
//        }
//        for (int i = array.length - 1; i >= 0; i--) {
//            System.out.print(array[i] + " ");
//        }

//        int[] array = {1, 4, 6, 3, 8};
//        System.out.println(Arrays.toString(array)); // [1, 4, 6, 3, 8]

        // Задача. Посчитать в массиве сумму отрицательных элементов (массив вводит пользователь)
//        int n, sum = 0;
//        System.out.print("n = ");
//        n = input.nextInt();
//
//        int[] array = new int[n];
//        for (int i = 0; i < array.length; i++){
//            System.out.print("-> ");
//            array[i] = input.nextInt();
//            if (array[i] < 0){
//                sum += array[i];
//            }
//        }
//        System.out.println(Arrays.toString(array));
//        //Делаем for для проверки на отрицательные значения
////        for (int i = 0; i < array.length; i++){
////            if (array[i] < 0){
////                sum += array[i];
////            }
////        }
//        System.out.println("Сумма отрицательных элементов массива: " + sum);

        //Задача. Ищем минимальный элемент массива. [3] {9, 2, 45}
//        int n;
//        System.out.print("n = ");
//        n = input.nextInt();
//
//        int[] array = new int[n];
//        for (int i = 0; i < array.length; i++) {
//            System.out.print("-> ");
//            array[i] = input.nextInt();
//        }
//        int min = array[0]; // 9
//        for (int i = 0; i < array.length; i++) {
//            if (array[i] < min) { // 1)9<9 false; 2)2<9 true; 3)45<2 false
//                min = array[i]; // 1)9; 2)2; 3)2
//            }
//        }
//        System.out.println(Arrays.toString(array));
//        System.out.println("Минимальный элемент массива: " + min);
// ДЗ от 13.12.23 часть 2 (1.24)

        // Лекция 18.12.2023 часть 1
        //Задача. Массив. Начало и конец. Вывести на экран числа диапазона. от 5 до 10.
//        System.out.print("Введите начало диапазона: ");
//        int k = input.nextInt(); // 5
//        System.out.print("Введите конец диапазона: ");
//        int n = input.nextInt(); // 10
//        int[] array = new int[n - k + 1]; // сюда будет сохраняться массив. Задаем длину массива. Если не делать действие,
//        // то длинна массива будет равна 10. Так как мы ввели конец массива и эта же переменная указывает длину массива.
//
//        for (int i = 0, j = k; i <= n - k; i++, j++) { // i=1, j=6; i=2, j=7; i=3, j=8; i=4, j=9; i=5, j=10; i=6, j=11 - false цикл завершен.
//            array[i] = j; // array[0] = 5; array[1] = 6; array[2]=7; array[3]=8; array[4]=9; array[5]=10
//            System.out.print(array[i] + "\t");
//        }
//
//        System.out.println("\n" + Arrays.toString(array));
// Копирование массива
//        int[] a1 = {1, 2, 3, 4};
//        int[] a2 = a1;
//        a1[0] = 5; // внесли изменение в массив и поменяли оба массива.
//        System.out.println("\n" + Arrays.toString(a1));
//        System.out.println("\n" + Arrays.toString(a2));
// Корректная замена данных в массиве и копирование массива.
//        int[] a1 = {1, 2, 3, 4};
//        int[] a2 = new int[a1.length]; // мы привязываемся только к длинне. пока в нем (0)
//        //int[] a2 = new int[a1.length + 5]; // так мы можем увеличить длину массива.
//        //int[] a2 = new int[a1.length -1]; // мы не можем так сокращать массив. Увеличивать длину массива можно, сокращать нет.
//        for(int i = 0; i < a1.length; i++){ // a1.length = 4; 4-1=3
//            a2[i] = a1[i]; // a2[0] = a1[0] - копируем массив. a2[3] = a1[3]
//        }
//        //a1[0] = 5; // меняем данные только в массиве a1.
//        System.out.println("\n" + Arrays.toString(a1));
//        System.out.println("\n" + Arrays.toString(a2));

        // Генерация случайных чисел.
//        double a = Math.random() * 3; // выдает случайное число от 0 до 1 не включая 1. Можем сразу совершитьт действие. От 0 до 3 не включая 3.
//        System.out.println(a); // Math.random() * (max - min) + min; Это дает возможность сдвинуть начальное значение
//        // от 2 до 7 (не включая 7)
//        double b = Math.random() * 5 + 2; // 2 - min; 5 - max. Обычно записывают так (2 + Math.random() * 5; 2+5 = 7 - это максимальное значение для этого примера.
        // Когда мы добавляем (+), то мы указываем диапазон от ...
//        System.out.println(b);

        // Отрицательные значения. от -5 до 5 (не включая 5)
//        double c = Math.random() * 10 - 5; // Math.random() * (5 - min) + min;
//        System.out.println(c);

        // Целые числа от 0 до 3
//        int d = (int) (Math.random() * 3); // при преобразовании данных нужно оператор записывать в скобках
//        System.out.println(d);
        // от 3 до 5 Math.random() * (max - min) + min; 5-3=2
        //int e = (int) (Math.random() * 2 + 3);
//        int e = 3 + (int) (Math.random() * 2 ); // обычная запись
//        System.out.println(e);
        // часть 2
        // Диапазон с включением максимальной границы
        // от -5 до 5 (включительно)
//        int f = (int) (Math.random() * 10 + 1 -5);
//        System.out.println(f);
        // Math.random() * (5-(-5)) + 1 + (-5)

        // -2->4 (включительно)
//        int g = (int) (Math.random() * 6 + 1 - 2); // (5-(-2) + (-2) = 7 - 2 или 6+1-2.
//        System.out.println(g);

        // Заполняем массив случайными числами
//        int[] array = new int[10];
//        for (int i = 0; i < array.length; i++){
////            array[i] = (int) (Math.random() * 10); // от 0 до 10 (не включая 10)
////            array[i] = (int) (Math.random() * 12 + 2); // от 2 до 14 (не включая 14)
//            array[i] = (int) (Math.random() * 31 -15); // от -15 до 16 (не включая 16)
//        }
//        System.out.println(Arrays.toString(array));

        //Задача. В массиве на 20 элементов (от 10 до 50) посчитать количество четных элементов и найти сумму нечетных
//        int sum = 0, count = 0;
//        int[] array = new int[20];
//        for (int i = 0; i < array.length; i++){
//            array[i] = (int) (Math.random() * 40 + 10);
//        }
//        System.out.println(Arrays.toString(array));
//        for (int i = 0; i < array.length; i++) {
//            if (array[i] % 2 == 0) {
//                count++; // если четное (%2=0) то увеличиваем количество
//            } else {
//                sum += array[i]; // иначе суммируем нечетные.
//            }
//        }
//        System.out.println("Количество четных элементов: " + count);
//        System.out.println("Сумма нечетных элементов: " + sum);

        // for еще в одном виде
//        int[] numbers = {10, 20, 30, 40, 50};
//        for (int i = 0; i < numbers.length; i++){
//            System.out.print(numbers[i] + " ");
////            System.out.println(++numbers[i] + " "); //  в этом случае мы можем перезаписать исходные данные массива.
//        }
//        System.out.println();
//// for (объявление_переменной : выражение) {} // это for each
//        for (int x: numbers) { // Новая переменная и название массива. Инициализация переменной делается один раз. Для случайного заполнения массива не подходит.
//            // Ей присваивается значение 1-го элемента последовательности. Потом в нее попадает поочереди каждое следующее значение.
//            // Благодаря for each мы можем перезаписывать элементы только для вывода.
//            //System.out.print(x + " "); // не используем индексы, выводим каждый элемент.
////            System.out.print(x * 2 + " "); // можем делать действие. Но перезаписать переменную нельзя.
////            System.out.print(++x + " "); // А вот так перезаписать можно. x = x + 1. Повлияло только в момент вывода.
//            System.out.println("Элемент массива " + x); // Мы можем сделать вывод массива как нам нужно (Оформление) с разным форматированием.
//        }
//        System.out.println();
//        System.out.println(Arrays.toString(numbers)); // Контроль показа элементов.

        // Массивы строковых значений
//        String[] names = {"Олег", "Иван", "Дима", "Юля"};
//        for (String name : names){ // Это for each, который позволил вывести все элементы массива в нужном нам виде.
//            System.out.println(name);
//        }

        // Недостатки Массива
//        String[] cities = {"Брянск", "Иркутск", "Владивосток", "Армавир"}; // 4
//        //cities[0] = "Сочи"; // Так мы заменим город в исходном массиве.
//        System.out.println(Arrays.toString(cities));
//        // Этот массив представляет собой маленькую базу данных. Теперь нам нужно добавить еще город.
//        // Можем при помощи создания еще одного массива.
//        String[] cities2 = new String[cities.length + 1]; // 5 - увеличили величину массива.
//        for (int i = 0; i < cities.length; i++){ // копируем массив с присвоениме значений по очереди.
//            cities2[i] = cities[i];
//        }
//        cities2[cities.length] = "Красноярск"; // Добавляем элемент в новый массив. Так как у нас есть место в новом массиве таким образом мы можем добавить новое значение через длинну старого массива.
////        cities[0] = "Сочи"; // так мы заменим город тоже только в исходном массиве.
////        System.out.println(Arrays.toString(cities));
//        System.out.println(Arrays.toString(cities2));

        // Динамические массивы
//        ArrayList <String> cities = new ArrayList<>(); // Другой тип создания массива. Но в нем мы можем делать изменения.
        // А именно менять величину массива.
//        cities.add("Брянск"); // это метод включения в массив данных, в том числе увеличивать длину.
//        cities.add("Иркутск");
//        cities.add("Владивосток");
//        cities.add("Армавир");
//        //cities.add("Красноярск");
//        cities.add(1,"Красноярск"); // Что бы так получилось нужно перед "Красноярск" ввести (1,).
//
//        System.out.println(cities.get(2)); // Получаем значение элемента по заданному индексу. Вывели Владивосток.
//
//        for (String city : cities) {
//            System.out.println(city + " ");
//        }
//        System.out.println("\n" + cities.indexOf("Владивосток")); // Получаем индекс элемента по заданному значению.

        // ДЗ 9 от 18.12.23. Заполнить массив на 10 элементов уникальными значениями в диапазоне от 0 до 10 (10 не включен). То есть нужно сделать проверку случайных чисел на уникальность и только потом ввести в массив.

        // Лекция от 20.12.2023
//        ArrayList<String> cities = new ArrayList<>();
//        cities.add("Брянск");
//        cities.add("Иркутск");
//        cities.add("Владивосток");
//        cities.add("Армавир");
//        cities.add(1, "Красноярск"); // Перепрыгивать через индексацию не можем. (12,) - будет ошибка, так как 12-го элемента еще не создано.
//
//        System.out.println(cities.get(2));
//
//        for (String city : cities) {
//            System.out.println(city + " ");
//        }
//        System.out.println("\n" + cities.indexOf("Владивосток"));
//        cities.set(2, "Курск"); // Метод позволяет установить новое значение по заданному индексу. (Индекс, "Значение")
//        cities.set(12, "Курск"); // Так работать не будет. Мы не сможем увеличить массив таким образом. Только для существующих индексов.
//        for (String city : cities) {
//            System.out.print(city + " ");
//        }

        // Что внутри массива
//        ArrayList<String> cities = new ArrayList<>();
//        cities.add("Брянск");
//        cities.add("Иркутск");
//        cities.add("Владивосток");
//        cities.add("Армавир");
//        cities.add(1, "Красноярск"); // Перепрыгивать через индексацию не можем. (12,) - будет ошибка, так как 12-го элемента еще не создано.
//
//        System.out.println(cities.get(2));
//
//        for (String city : cities) {
//            System.out.println(city + " ");
//        }
//        System.out.println("\n" + cities.indexOf("Владивосток"));
//        cities.set(2, "Курск"); // Метод позволяет установить новое значение по заданному индексу. (Индекс, "Значение")
//        //cities.set(12, "Курск"); // Так работать не будет. Мы не сможем увеличить массив таким образом. Только для существующих индексов.
//        for (String city : cities) {
//            System.out.print(city + " ");
//        }
//        if (cities.contains("Курск")){ // Проверка на существование в массиве именно ArrayList.
//            System.out.println("\nArrayList содержит Курск"); //true, мы попали в if и напечаталось "ArrayList содержит Курск".
//        }
//        System.out.println(cities.contains("Курск")); // true. Метод возвращает булево значение.

        // Можем удалить элемент
//        ArrayList<String> cities = new ArrayList<>();
//        cities.add("Брянск");
//        cities.add("Иркутск");
//        cities.add("Владивосток");
//        cities.add("Армавир");
//        cities.add(1, "Красноярск");
//
//        System.out.println(cities.get(2));
//
//        for (String city : cities) {
//            System.out.println(city + " ");
//        }
//        System.out.println("\n" + cities.indexOf("Владивосток"));
//        cities.set(2, "Курск");
//        cities.remove("Армавир"); // Удаляем элемент. Если есть одинаковые, то удалится как правило с лева на право.
//        cities.remove(1); // Этот метод удаляет по заданному индексу. Так корректно. Можно сделать проверку на несуществующие элементы.
//        for (String city : cities) {
//            System.out.print(city + " ");
//        }
//        if (cities.contains("Курск")) {
//            System.out.println("\nArrayList содержит Курск"); //true, мы попали в if и напечаталось "ArrayList содержит Курск".
//        }
//        System.out.println(cities.contains("Курск"));
//        System.out.println(cities.size()); // Длинна динамического массива.
//
//        for (int i = 0; i < cities.size(); i++) { // Цикл для динамического массива.
//            System.out.println(cities.get(i)); // Вывод динамического массива при помощи цикла.
//        }// Если мы обратимся к индексу, которого нет, то это будет ошибка.

        // Работа с динамическим массивом (числа) 0.28
//        int n, k; // Пользователь будет вводить в нее значения.
//        ArrayList<Integer> mas = new ArrayList<>(); // Пустой массив
//        System.out.println("Введите элемент из списка. Условия выхода 0 или отрицательное число: ");
//        while ((n = input.nextInt()) > 0){ // Сравнение со значением 0. Нужно сделать в скобках, так как приоритет действий такой, сначала сравнение, потом все остальное, по этому ввод переменной нужно сделать в скобках, чтобы повысить приоритет ввода.
//        mas.add(n); // Добавляем в массив данные.
//        }
//
//        System.out.print("Введите индекс: ");
//        k = input.nextInt(); // Объявили вверху.
//        mas.remove(k); // Хотим удалять значения под индексом (k).
//        for (int m: mas){ // Для заполнения массива
//            System.out.print(m + "\t"); // Через табуляцию.
//        }

        //Задача. Заполнить массив из 10 элем., случ., числ. от 0 до 100. Найти максимальное значение и перенести в начало.
//        int max, ind;
//        ArrayList<Integer> mas = new ArrayList<>();
//        for ( int i = 0; i < 10 ; i++){ // Цикл для генерирования.
//            mas.add((int) (Math.random() * 100)); // Генерируем случайные числа от 0 до 100 (без 100).
//        }
//        for (int m : mas){ // Через цикл выводим массив с нужным нам форматированием.
//            System.out.print(m + "\t");
//        }
//        max = mas.get(0); // Со статическим массивом не работает.
//        for (int i = 0; i < 10; i++) {
//            if (mas.get(i) > max){
//                max = mas.get(i);
//            }
//        }
//        System.out.println("\nMax: " + max);
//        ind = mas.indexOf(max); // Получаем индекс максимального элемента.
//        System.out.println("Index max: " + ind);
//        mas.remove(ind);
////        mas.remove(max); // С числовыми значениями такой способ не работает.
//        mas.add(0, max); // Переносим максимальное число в начало.
//        for (int m : mas){
//            System.out.print(m + "\t");
//        }

        // Задача. Написать функцию, которая создает комбинацию двух массивов, чтобы получился новый массив.
////        ArrayList<Integer> a = new ArrayList<>(Arrays.asList(1, 2, 3)); // Создаем динамический массив в ручную.
//        ArrayList<Integer> a = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7)); // Увеличили первый массив для освоения соединения. Теперь он больше второго.
////        ArrayList<Integer> b = new ArrayList<>(Arrays.asList(11, 22, 33)); // Создаем динамический массив в ручную.
//        ArrayList<Integer> b = new ArrayList<>(Arrays.asList(11, 22, 33, 44 ,55)); // Увеличили массив для того чтобы, освоить соединение массивов разной длинны. Второй был больше исходного.
//        ArrayList<Integer> c = new ArrayList<>(Arrays.asList()); // Создаем пустой динамический массив для объединения.
//        if (a.size() > b.size()) { // Используя if && else мы смогли разными способами соединять динамические массивы разной длинны и одинаковой.
//            for (int i = 0; i < b.size(); i++) { // Сперва ограничимся массивом (b), так как он меньше.
//                c.add(a.get(i));
//                c.add(b.get(i)); // Можно добавлять без дополнительных условий, при условии, что массивы одинакового размера.
//            }
//            for (int i = a.size(); i < b.size(); i++) { // Переменная i существует только для текущего for.
//                c.add(b.get(i));
//            }
//        } else {
//            for (int i = 0; i < a.size(); i++) { // Сперва ограничимся массивом (а).
//                c.add(a.get(i));
//                c.add(b.get(i)); // Можно добавлять без дополнительных условий, при условии, что массивы одинакового размера.
//            }
//        }
//        for (int i = b.size(); i < a.size(); i++){ // Переменная i существует только для текущего for.
//            c.add(a.get(i));
//        }
//
//
////        for (int m : a) {
////            System.out.print(m + "\t");
////        }
////            for (int m : b) { // Как работает (m)? Можно ли вводить дополнительную переменную, для обозначения элемента массива для такого вывода, если нужно вывести совместно разные массивы?
////            System.out.print(m + "\t");
////        }
//        for(int m : c){
//            System.out.print(m + "\t");
//        }

        //Многомерные массивы. Вывод массивов по разным осям. При помощи вложенных данных. Чаще всего делают двух мерный массив. Для работы с такими массивами используют вложенные циклы.
// Массивы с одинаковой длинной.
//        int[][] num = {{0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11}}; // Одинаковое количество массивов. В нем 3 массива.
//        System.out.println(num.length); // 3 - основные массивы.
//        System.out.println(Arrays.toString(num)); // 3 [] со значениями индентификатора адреса памяти.
//        for (int i = 0; i < num.length; i++) { // Получим 3 итерации, так как у нас 3 массива. При этом [i] - стал индексом двумерного массив и содержит элементы вложенного массива. Т.е.массив с индексом i.
//            System.out.println(Arrays.toString(num[i])); // Чтобы попасть внутрь массивов и вывести элементы.
//        }
//        System.out.println(num[1][3]); // Обращаемся к массиву с индексом [1] и в нем к элементу с индексом [3]: 7
//        for (int i = 0; i < num.length; i++) { //i = 0, i < 3 - количество вложенных массивов; Этот цикл считает только внешние элементы и выдаст количество элементов каждого массива.
//            for (int j = 0; j < num[i].length; j++) { // j = 0, j < 4 - длина каждого вложенного элемента (чтобы 4 не попала делаем условие i<4, так как индекс = length-1; Определем длинну в каждом вложенном элементе. Вложенный цикл дудет отрабатывать полностью после каждой итереции внешнего. И только потом перейдем во внешний
//                System.out.print(num[i][j] + "\t"); // num[0][0] - это первый элемент [0][3] - последний элемент первого массива; num[2][3] - это последний элемент. Вывели каждый элемент по отдельности.
//            }
//            System.out.println();
//        }
// Задача. Возвести каждый элемент матрицы в квадрат.
//        int[][] num = {{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}};
//        for (int i = 0; i < num.length; i++) {
//            for (int j = 0; j < num[i].length; j++) {
//                System.out.print(num[i][j] + "\t");
//            }
//            System.out.println();
//        }
//        System.out.println();
//        for (int i = 0; i < num.length; i++) {
//            for (int j = 0; j < num[i].length; j++) {
//                num[i][j] *= num[i][j]; // num[i][j] = num[i][j] * num[i][j] - перезаписываем переменную, исходные данные в массиве изменятся.
//                System.out.print(num[i][j] + "\t");
//                //System.out.println(num[i][j] * num[i][j]); // Вариант без перезаписывания элементов.
//            }
//            System.out.println();
//        }

        // Задача. Графика с массивом
//        int n  = 5, m = 7;// Добавили переменную (m). Сперва была одна переменная (n) - рисовался прямоугольник с одинаковым количеством (*) по вертикали и горизонтали. После добавлния переменной (m) мы смогли нарисовать прямоугольник с разным количеством (*) по вертикали и горизонтали.
//        char[][] graph = new char[n][m]; // поменяли (n) на (m) - выделяем память под эти элементы.
//        for (int i = 0; i < n; i++) {
//            for (int j = 0; j < m; j++) {
//                graph[i][j] = '*'; // одинаковые символы.
//                System.out.print(graph[i][j] + "  "); // 2а пробела
//            }
//            System.out.println();
//
//        }

        //Задача. Нужно случайным образом заполнить двумерный список размерностью 3х4, цифрами от -20 до 10.
        // И найти количество (-) элементов.
//        int n = 3, m = 4, count = 0; //для подсчета отрицательных значений
//        int[][] mas = new int[n][m]; // это размер массива. Он пока пустой.
//        for (int i = 0; i < n; i++){ // Этот for для создания массивов со случайными значениями.
//            for (int j = 0; j < m; j++) {
//        mas[i][j] = (int) (Math.random() * 30 - 20); // Заполняем массивы случайными элементами.
////            if (mas[i][j] < 0){ // Нет разницы где будет делаться этот подсчет.
////                count ++;
////                }
//            }
//        }
//        for (int i = 0; i < n; i++){ // Этот for для вывода массивов со случайными значениями.
//            for (int j = 0; j < m; j++) {
//                System.out.print(mas[i][j] + "\t\t"); // Выводим массив (i) с элементами (j) сразу после циклов.
//                if (mas[i][j] < 0){ // Нет разницы в каком (for) будет делаться этот подсчет. Главное после создания элементов. При этом обязательно в цикле, так как [i][j] должны быть в поле видимости.
//                    count ++;
//                }
//            }
//            System.out.println(); // Это позволит перейти на новую строку после отработки внешнего цикла.
//        }
//        System.out.println("Количество отрицательных элементов: " + count);

        // Как эти элементы хранятся в памяти?
        // В одной ячейке хранится адрес памяти, в других элементы массива.
        // Двумерный массив mas. Адрес каждого массива записывается в ячейки [i] элементы массивов хранятся каждый в своей ячейке [j].

        // ДЗ от 20.12.2023. Случайным образом заполнить двумерный массив, размером 6х6 цифрами от 0 до 11 и одинарный массив 6 чисел.
        // Нужно четные строки двумерного массива заменить одномерным.

        // Лекция от 25.12.2023. Продолжаем двумерные массивы.

        // Задача. Найти в двумерном массиве строку, имеющую минимальную сумму элементов.
//        int arr[][] = new int [3][5];
//        int sum = Integer.MAX_VALUE; // Сумма предыдущей строки. Для инициализации суммы.
//        int tmp = 0, n = 1; // Для расчета суммы каждой строки. При каждой итерации.
//        for (int i = 0; i < arr.length; i++) { // Это 3. Это более универсальный способ. Так как можем вводить длинну массива пользователем.
//            for (int j = 0; j < arr[i].length; j++) { // Это 5.
//                arr[i][j] = (int) (Math.random() * 100);
//                System.out.print(arr[i][j] + "\t\t");
//            }
//            System.out.println();
//        }
//        for (int i = 0; i < arr.length; i++) {
//            for (int j = 0; j < arr[i].length; j++) {
//                tmp += arr[i][j];
//            }
//            if (sum > tmp){ //Так как sum при первой итерации больше tmp мы попадаем в этот цикл.
//                sum = tmp; // После первой итерации в sum попадает tmp.
//                n = i;
//            }
//            tmp = 0;
//            System.out.println("Сумма элементов" + (i + 1) + "строки: " + sum); // (i + 1) таким образом мы получаем именно выражение, а не соединение символов (конкатенация).
//                }
//        System.out.println("\nСтрока с минимальной суммой элементов: " + sum + "имеет номер "+ (n+1));

        //Разное количество элементов в строках.Зубчатый массив
//        int[][] mas = new int[3][]; // Оставляем пустой для указания элементов
//        mas[0] = new int[2]; // Указываем, что в массиве [0] будет 2 элемента.
//        mas[1] = new int[3];
//        mas[2] = new int[4]; // Зубчатый массив.
//        for (int i = 0; i < mas.length; i++) {
//            for (int j = 0; j < mas[i].length; j++) {
//                System.out.print(mas[i][j] + "\t\t"); // Выводит строку из вложенного цикла.
//            }
//            System.out.println();
//        }
//        for (int i = 0; i < mas.length; i++) {
//            for (int j = 0; j < mas[i].length; j++) {
//mas[i][j] = input.nextInt(); // При таком способе массив заполняется по порядку, по строчно.
//            }
//        }
//        for (int i = 0; i < mas.length; i++) {
//            for (int j = 0; j < mas[i].length; j++) {
//                System.out.print(mas[i][j] + "\t\t");
//            }
//            System.out.println();
//        }

        //Другой вариант. Заполняем вручную.
//        int[][] mas = new int[3][];
//        mas[0] = new int[]{1, 2}; // Такое выделение памяти обязательно.
//        mas[1] = new int[]{3, 4, 5};
//        mas[2] = new int[]{6, 7, 8, 9};
//        for (int i = 0; i < mas.length; i++) {
//            for (int j = 0; j < mas[i].length; j++) {
//                System.out.print(mas[i][j] + "\t\t");
//            }
//            System.out.println();
//        }
        // Короткая запись зубчатого массива.
//        int[][] mas1 = new int[][]{{1, 2}, {3, 4, 5},{6, 7, 8, 9}};
//        for (int i = 0; i < mas.length; i++){
//            for (int j = 0; j < mas[i].length; j++) {
//                System.out.print(mas[i][j] + "\t\t");
//            }
//            System.out.println();
//        }

        //Задача. Заполнить зубчатый массив случайным образом от 0 до 15.
//        int n = 5;
//        int count = 0;
//        int arr[][] = new int[n][];
//        for (int i = 0; i < arr.length; i++){
//            arr[i] = new int[i + 1]; // Без (+1) у нас не будет отображаться первая строка. Есть строка (0), но в нее ничего не попадает, так как ячеек в ней нет. Так же получится заполнить полностью все элементы.
//        }
//        for (int i = 0; i < arr.length; i++) { // Цикл для заполнения.
//            for (int j = 0; j < arr[i].length; j++) {
//                arr[i][j] = count++; // (Пост инкремент) Первый попадет 0, а потом будет увеличиваться и пересохраняться. При ++count мы сразу при первой итерации получаем 1, а нам нужно сперва 0.
//            }
//        }
//        for (int i = 0; i < arr.length; i++) {
//            for (int j = 0; j < arr[i].length; j++) {
//                System.out.print(arr[i][j] + "\t\t");
//            }
//            System.out.println();
//        }

        // Делаем зубчатый массив перевернутый.
//        int n = 5;
//        int count = 10;
//        int arr[][] = new int[n][];
//        for (int i = 0; i < arr.length; i++){
//            arr[i] = new int[arr.length - i]; // Это для разворота. 1) 5-0; 2)5-1 т.д.
//        }
//        for (int i = 0; i < arr.length; i++) {
//            for (int j = 0; j < arr[i].length; j++) {
//                arr[i][j] = count++;
//            }
//        }
//        for (int i = 0; i < arr.length; i++) {
//            for (int j = 0; j < arr[i].length; j++) {
//                System.out.print(arr[i][j] + "\t\t");
//            }
//            System.out.println();
//        }

        //Где применяем зубчатые массивы.
        // Треугольник Паскаля.
//        int n = 5;
//        int tp[][] = new int[n][];
//        for (int i = 0; i < n; i++) {
//            tp[i] = new int[i + 1];
//            tp[i][0] = 1;
//            tp[i][i] = 1; // Заполнили последний элемент массивов.
//            for (int j = 1; j < i; j++) { // Вложенный for для заполнения других ячеек. При первой итерации наружного for мы сюда не попадаем. 1 < 0 false. 1 < 1 false. 1 < 2 true - попали во вложенный цикл.
//                tp[i][j] = tp [i - 1][j - 1] + tp[i - 1][j]; // Это расчет значений ячеек.
//            }
//        }
//        for (int i = 0; i < tp.length; i++) {
//            for (int j = 0; j < n - i; j++){
//                System.out.print("  "); // 2__
//            }
//            for (int j = 0; j < tp[i].length; j++) {
//                System.out.print(tp[i][j] + "   "); // 3___
//            }
//            System.out.println();
//        }


    }
}
